## `utils_fastqc.R' contains utility functions to analyze outputs from the
## FastQC program (http://www.bioinformatics.babraham.ac.uk/projects/fastqc/)
## Copyright (C) 2014-2015 Institut National de la Recherche Agronomique (INRA)
## License: GPL-3+
## Author: Timothée Flutre
## Versioning: https://github.com/timflutre/quantgen
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program. If not, see <http://www.gnu.org/licenses/>.

##' Reads a "fastqc_data.txt" file generated by FastQC.
##'
##' Heavily inspired from readFastQC() in the Repitools package.
##' @param file the name of the file which the data are to be read from
##' @return list
##' @author Timothée Flutre
read.fastqc.txt <- function(file){
    stopifnot(file.exists(file),
              grepl(pattern="##FastQC", x=readLines(file, n=1)))
    temp <- readLines(file)
    temp <- gsub("#", "", temp)
    temp <- temp[!grepl(">>END_MODULE", temp)]
    temp <- split(temp, cumsum(grepl("^>>", temp)))[-1]
    names(temp) <- sapply(temp, function(x) {
        gsub("^>>", "", gsub("\t.*", "", gsub(" ", "_", x[1])))
    })
    temp <- lapply(temp, function(x) {
        if(length(x)==1)
            return(data.frame())
        x <- strsplit(x[-1], split="\t")
        tab <- as.data.frame(do.call(rbind, x[-1]), stringsAsFactors=FALSE)
        for(i in 1:ncol(tab))
            if(!any(is.na(suppressWarnings(as.numeric(tab[,i])))))
                tab[,i] <- as.numeric(tab[,i])
        colnames(tab) <- x[[1]]
        tab
    })
    return(temp)
}

##' Loads several zip archives generated by FastQC.
##'
##' Zip archives are decompressed in a temporary directory which is removed afterwards.
##' @param path character vector of the path to the directory containing the zip archives (will be followed by "*_fastqc.zip")
##' @param glob character vector with wildcard(s) to find zip archives
##' @return list of lists (one per zip archive)
##' @author Timothée Flutre
read.fastq.zips <- function(path=".", glob="*_fastqc.zip"){
    zip.archives <- Sys.glob(paste(path, glob, sep="/"))
    if(length(zip.archives) == 0)
        stop("not a single zip archive was found", call.=FALSE)
    message(paste("nb of zip archives detected:", length(zip.archives)))
    all.qc <- lapply(zip.archives, function(zip.archive){
        zipdir <- tempfile()
        dir.create(zipdir)
        unzip(zip.archive, exdir=zipdir)
        f.base <- sub(".zip", "", basename(zip.archive))
        qc <- read.fastqc.txt(paste(zipdir, "/", f.base, "/fastqc_data.txt",
                                    sep=""))
        unlink(zipdir)
        qc
    })
    names(all.qc) <- sapply(zip.archives, function(zip.archive){
        sub("_fastqc.zip", "", basename(zip.archive))
    })
    return(all.qc)
}

##' Returns the number of reads per entry in a set of zip archives generated by FastQC.
##'
##' To be used after read.fastq.zips().
##' @param all.qc returned value from read.fastq.zips()
##' @return numeric vector
##' @author Timothée Flutre
nreads.fastqc <- function(all.qc){
    stopifnot(is.list(all.qc), ! is.null(names(all.qc)))
    sapply(all.qc, function(qc){
        as.numeric(qc[["Basic_Statistics"]]$Value[qc[["Basic_Statistics"]]$Measure
                                                  == "Total Sequences"])
    })
}

##' Creates a bar plot with the number of reads per entry in a set of zip archives generated by FastQC.
##'
##' To be used after nreads().
##' @param x numeric vector with the number of reads per entry
##' @param main an overall title for the plot
##' @return None
##' @author Timothée Flutre
barplot.nreads.fastqc <- function(x, main=""){
    stopifnot(is.vector(x), is.numeric(x), ! is.null(names(x)))
    par(mar=c(10, 7, 4, 1))
    bp <- barplot(sort(x), xaxt="n", xlab="", ylab="Number of reads",
                  main=main)
    axis(1, at=bp, labels=FALSE)
    text(bp, par("usr")[3], srt=45, adj=1.1,
         labels=names(sort(x)), xpd=TRUE)
}

##' Returns the number of reads per quality score per entry in a set of zip archives generated by FastQC.
##'
##' To be used after read.fastq.zips().
##' @param all.qc returned value from read.fastq.zips()
##' @param perc boolean, return percentage of reads if TRUE, number of reads if FALSE, requires nreads
##' @param nreads return value from nreads.fastqc()
##' @return numeric matrix with entries in rows and number of reads per quality in columns
##' @author Timothée Flutre
quals.fastqc <- function(all.qc, perc=FALSE, nreads=NULL){
    stopifnot(is.list(all.qc), ! is.null(names(all.qc)),
              ifelse(perc, ! is.null(nreads), TRUE))
    N <- length(all.qc)
    qual <- matrix(NA, nrow=N, ncol=50)
    for(i in 1:N)
        qual[i, all.qc[[i]][["Per_sequence_quality_scores"]][,"Quality"]] <-
            all.qc[[i]][["Per_sequence_quality_scores"]][,"Count"]
    rownames(qual) <- names(all.qc)
    if(perc)
        for(i in 1:nrow(qual))
            qual[i,] <- (qual[i,] / nreads[i]) * 100
    return(qual)
}

##' Plot the number of sequences per quality score with one curve per dataset.
##'
##' To be used after quals.fastqc().
##' @param qual matrix with dataset in rows and quality scores in columns
##' @param main an overall title for the plot
##' @param ylab a title for the y axis
##' @param legend.x the x y co-ordinates to be used to position the legend
##' @param legend.y the y co-ordinates to be used to position the legend
##' @return None
##' @author Timothée Flutre
plot.nbseq.qual <- function(qual,
                            main="Quality control",
                            ylab="Number of sequences",
                            legend.x="topleft",
                            legend.y=NULL){
    stopifnot(is.matrix(qual),
              ! is.null(rownames(qual)))

    lowest.qual <- NA
    for(j in 1:ncol(qual)){
        if(any(! is.na(qual[,j]))){
            lowest.qual <- j
            break
        }
    }

    highest.qual <- NA
    for(j in ncol(qual):1){
        if(any(! is.na(qual[,j]))){
            highest.qual <- j
            break
        }
    }

    lowest.count <- min(qual[,lowest.qual])
    highest.count <- max(qual[,lowest.qual])
    for(j in lowest.qual:highest.qual){
        lowest.count <- min(lowest.count, qual[,j], na.rm=TRUE)
        highest.count <- max(highest.count, qual[,j], na.rm=TRUE)
    }

    plot(x=0, y=0,
         xlim=c(lowest.qual, highest.qual),
         ylim=c(lowest.count, highest.count),
         xlab="Phred quality", ylab=ylab,
         main=main,
         type="n")
    for(i in 1:nrow(qual)){
        idx <- which(! is.na(qual[i,]))
        points(x=idx, y=qual[i,idx], col=i, pch=i, type="b")
    }
    axis(side=4)
    legend(x=legend.x, y=legend.y, legend=rownames(qual),
           col=1:nrow(qual), pch=1:nrow(qual), bty="n")
}

##' Returns the adapter content along the reads per entry in a set of zip archives generated by FastQC.
##'
##' To be used after read.fastq.zips().
##' @param all.qc returned value from read.fastq.zips()
##' @param adp name of the adapter to plot (default="Illumina Universal Adapter")
##' @return numeric matrix with entries in rows and number of reads per quality in columns
##' @author Timothée Flutre
adp.contents.fastqc <- function(all.qc, adp="Illumina Universal Adapter"){
  stopifnot(is.list(all.qc), ! is.null(names(all.qc)),
            adp %in% c("Illumina Universal Adapter",
                       "Illumina Small RNA Adapter",
                       "Nextera Transposase Sequence"))
  N <- length(all.qc)
  positions <- all.qc[[1]]$Adapter_Content[["Position"]]
  adp.content <- matrix(NA, nrow=N, ncol=length(positions),
                        dimnames=list(names(all.qc), positions))
  for(i in 1:N)
    adp.content[i,] <- all.qc[[i]]$Adapter_Content[[adp]]
  return(adp.content)
}

##' Plot the content in adapters (%) along the reads per entry in a set of zip archives generated by FastQC.
##'
##' To be used after adp.contents.fastqc().
##' @param adp.content matrix with datasets in rows and read positions in columns
##' @param lowest.adp lowest percentage of adapter content for the y-axis
##' @param highest.adp highest percentage of adapter content for the y-axis
##' @param main an overall title for the plot
##' @param legend.x the x y co-ordinates to be used to position the legend
##' @param legend.y the y co-ordinates to be used to position the legend
##' @return None
##' @author Timothée Flutre
plot.adp.content <- function(adp.content,
                             lowest.adp=NULL,
                             highest.adp=NULL,
                             main="Quality control",
                             legend.x="topleft",
                             legend.y=NULL){
    stopifnot(is.matrix(adp.content),
              ! is.null(rownames(adp.content)),
              ! is.null(colnames(adp.content)))

    positions <- sapply(strsplit(colnames(adp.content), "-"),
                     function(x){as.numeric(x[1])})

    if(is.null(lowest.adp))
      lowest.adp <- min(c(adp.content))
    if(is.null(highest.adp))
      highest.adp <- max(c(adp.content))

    plot(x=0, y=0,
         xlim=c(positions[1], positions[length(positions)]),
         ylim=c(lowest.adp, highest.adp),
         xlab="Positions (bp)",
         ylab="Adapter content (%)",
         main=main,
         type="n")
    for(i in 1:nrow(adp.content)){
        points(x=positions, y=adp.content[i,], col=i, pch=i, type="b")
    }
    axis(side=4)
    legend(x=legend.x, y=legend.y, legend=rownames(adp.content),
           col=1:nrow(adp.content), pch=1:nrow(adp.content), bty="n")
}

##' Returns the sequence length distribution per entry in a set of zip archives generated by FastQC.
##'
##' To be used after read.fastq.zips().
##' @param all.qc returned value from read.fastq.zips()
##' @return numeric matrix with entries in rows and number of reads per length in columns
##' @author Timothée Flutre
seq.lengths.fastqc <- function(all.qc){
  stopifnot(is.list(all.qc), ! is.null(names(all.qc)))
  N <- length(all.qc)
  positions <- lapply(1:N, function(i){
    all.qc[[i]]$Sequence_Length_Distribution[["Length"]]
  })
  positions <- unique(sort(sapply(
      strsplit(do.call(c, positions), "-"), function(x){
        as.numeric(x[1])
      })))
  seq.lengths <- matrix(0, nrow=N, ncol=length(positions),
                        dimnames=list(names(all.qc), positions))
  for(i in 1:N){
    tmp <- all.qc[[i]]$Sequence_Length_Distribution
    tmp$Length <- sapply(strsplit(tmp$Length, "-"), function(x){x[1]})
    seq.lengths[i, tmp$Length] <- tmp$Count
  }
  return(seq.lengths)
}

##' Plot the distribution of sequence lengths per entry in a set of zip archives generated by FastQC.
##'
##' To be used after seq.lengths.fastqc().
##' @param seq.length matrix with datasets in rows and number of sequences per length in columns
##' @param lowest.len lowest sequence length for the y-axis
##' @param highest.len highest sequence length for the y-axis
##' @param main an overall title for the plot
##' @param ylab label for the y-axis
##' @param legend.x the x y co-ordinates to be used to position the legend
##' @param legend.y the y co-ordinates to be used to position the legend
##' @param use.log use the log for the y-axis
##' @return None
##' @author Timothée Flutre
plot.seq.length <- function(seq.length,
                            lowest.len=NULL,
                            highest.len=NULL,
                            main="Quality control",
                            ylab="Number of sequences",
                            legend.x="topleft",
                            legend.y=NULL){
  stopifnot(is.matrix(seq.length),
            ! is.null(rownames(seq.length)),
            ! is.null(colnames(seq.length)))

  lengths <- sapply(strsplit(colnames(seq.length), "-"),
                    function(x){as.numeric(x[1])})

  if(is.null(lowest.len))
    lowest.len <- min(c(seq.length))
  if(is.null(highest.len))
    highest.len <- max(c(seq.length))

  plot(x=0, y=0,
       xlim=c(lengths[1], lengths[length(lengths)]),
       ylim=c(lowest.len, highest.len),
       xlab="Sequence lengths (bp)",
       ylab=ylab,
       main=main,
       type="n")
  for(i in 1:nrow(seq.length)){
    points(x=lengths, y=seq.length[i,], col=i, pch=i, type="b")
  }
  axis(side=4)
  legend(x=legend.x, y=legend.y, legend=rownames(seq.length),
         col=1:nrow(seq.length), pch=1:nrow(seq.length), bty="n")
}
