## `utils_fastqc.R' contains utility functions to analyze outputs from the
## FastQC program (http://www.bioinformatics.babraham.ac.uk/projects/fastqc/)
## Copyright (C) 2014 Institut National de la Recherche Agronomique (INRA)
## License: GPL-3+
## Author: Timothée Flutre
## Versioning: https://github.com/timflutre/quantgen
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program. If not, see <http://www.gnu.org/licenses/>.

##' Reads a "fastqc_data.txt" file generated by FastQC.
##'
##' Heavily inspired from readFastQC() in the Repitools package.
##' @param file the name of the file which the data are to be read from
##' @return list
##' @author Timothée Flutre
read.fastqc.txt <- function(file){
    stopifnot(file.exists(file),
              grepl(pattern="##FastQC", x=readLines(file, n=1)))
    temp <- readLines(file)
    temp <- gsub("#", "", temp)
    temp <- temp[!grepl(">>END_MODULE", temp)]
    temp <- split(temp, cumsum(grepl("^>>", temp)))[-1]
    names(temp) <- sapply(temp, function(x) {
        gsub("^>>", "", gsub("\t.*", "", gsub(" ", "_", x[1])))
    })
    temp <- lapply(temp, function(x) {
        if(length(x)==1)
            return(data.frame())
        x <- strsplit(x[-1], split="\t")
        tab <- as.data.frame(do.call(rbind, x[-1]), stringsAsFactors=FALSE)
        for(i in 1:ncol(tab))
            if(!any(is.na(suppressWarnings(as.numeric(tab[,i])))))
                tab[,i] <- as.numeric(tab[,i])
        colnames(tab) <- x[[1]]
        tab
    })
    return(temp)
}

##' Loads several zip archives generated by FastQC.
##'
##' Zip archives are decompressed in a temporary directory which is removed afterwards.
##' @param path character vector of the path to the directory containing the zip archives (will be followed by "*_fastqc.zip")
##' @param glob character vector with wildcard(s) to find zip archives
##' @return list of lists (one per zip archive)
##' @author Timothée Flutre
read.fastq.zips <- function(path=".", glob="*_fastqc.zip"){
    zip.archives <- Sys.glob(paste(path, glob, sep="/"))
    if(length(zip.archives) == 0)
        stop("not a single zip archive was found", call.=FALSE)
    message(paste("nb of zip archives detected:", length(zip.archives)))
    all.qc <- lapply(zip.archives, function(zip.archive){

        zipdir <- tempfile()
        dir.create(zipdir)

	tryCatch(unzip(zip.archive, exdir=zipdir),
	warning=function(w) {
	message(paste( basename(zip.archive),"could no be unzipped."))
	message("Original warning message:")
	message(w)}
	, error=function(e){
	message(paste( basename(zip.archive),"could no be unzipped."))
	message("Original error message:")
	message(e) }
	)

	tryCatch({f.base <- sub(".zip", "", basename(zip.archive))
	qc <- read.fastqc.txt(paste(zipdir, "/", f.base, "/fastqc_data.txt",
	sep=""))
	},
	warning=function(w) {
	message(paste(sub(".zip", "", basename(zip.archive)),".txt could no be found.",sep=""))
	message("Original warning message:")
	message(w)
	qc <- list(warn="warning")
	}
	, error=function(e){
	qc <- list(err="error")
	message(paste(sub(".zip", "", basename(zip.archive)),".txt could no be found.",sep=""))
	message("Original error message:")
	message(e) }
	) 
	unlink(zipdir)
	ifelse(exists("qc"),return(qc),return(list(warn="warning")))
	})
    names(all.qc) <- sapply(zip.archives, function(zip.archive){
        sub("_fastqc.zip", "", basename(zip.archive))
    })
    return(all.qc[sapply(all.qc,length)!=1])
}

##' Returns the number of reads per entry in a set of zip archives generated by FastQC.
##'
##' To be used after read.fastq.zips().
##' @param all.qc return value from read.fastq.zips()
##' @return numeric vector
##' @author Timothée Flutre
nreads.fastqc <- function(all.qc){
    stopifnot(is.list(all.qc), ! is.null(names(all.qc)))
    sapply(all.qc, function(qc){
        as.numeric(qc[["Basic_Statistics"]]$Value[qc[["Basic_Statistics"]]$Measure
                                                  == "Total Sequences"])
    })
}

##' Creates a bar plot with the number of reads per entry in a set of zip archives generated by FastQC
##'
##' To be used after nreads().
##' @param x numeric vector with the number of reads per entry
##' @param main an overall title for the plot
##' @return None
##' @author Timothée Flutre
barplot.nreads.fastqc <- function(x, main=""){
    stopifnot(is.vector(x), is.numeric(x), ! is.null(names(x)))
    par(mar=c(10, 7, 4, 1))
    bp <- barplot(sort(x), xaxt="n", xlab="", ylab="Number of reads",
                  main=main)
    axis(1, at=bp, labels=FALSE)
    text(bp, par("usr")[3], srt=45, adj=1.1,
         labels=names(sort(x)), xpd=TRUE)
}

##' Returns the number of reads per quality score per entry in a set of zip archives generated by FastQC.
##'
##' To be used after read.fastq.zips().
##' @param all.qc return value from read.fastq.zips()
##' @param perc boolean, return percentage of reads if TRUE, number of reads if FALSE, requires nreads
##' @param nreads return value from nreads.fastqc()
##' @return numeric matrix with entries in rows and number of reads per quality in columns
##' @author Timothée Flutre
quals.fastqc <- function(all.qc, perc=FALSE, nreads=NULL){
    stopifnot(is.list(all.qc), ! is.null(names(all.qc)),
              ifelse(perc, ! is.null(nreads), TRUE))
    N <- length(all.qc)
    qual <- matrix(NA, nrow=N, ncol=50)
    for(i in 1:N)
        qual[i, all.qc[[i]][["Per_sequence_quality_scores"]][,"Quality"]] <-
            all.qc[[i]][["Per_sequence_quality_scores"]][,"Count"]
    rownames(qual) <- names(all.qc)
    if(perc)
        for(i in 1:nrow(qual))
            qual[i,] <- (qual[i,] / nreads[i]) * 100
    return(qual)
}

##' Plot the number of sequences per quality score with one curve per dataset.
##'
##' To be used after quals.fastqc().
##' @param qual matrix with dataset in rows and quality scores in columns
##' @param main an overall title for the plot
##' @param ylab a title for the y axis
##' @param legend.x the x y co-ordinates to be used to position the legend
##' @param legend.y the y co-ordinates to be used to position the legend
##' @return None
##' @author Timothée Flutre
plot.nbseq.qual <- function(qual, main="Quality control",
                            ylab="Number of sequences",
                            legend.x="topleft",
                            legend.y=NULL){
    stopifnot(is.matrix(qual), ! is.null(rownames(qual)))

    lowest.qual <- NA
    for(j in 1:ncol(qual)){
        if(any(! is.na(qual[,j]))){
            lowest.qual <- j
            break
        }
    }

    highest.qual <- NA
    for(j in ncol(qual):1){
        if(any(! is.na(qual[,j]))){
            highest.qual <- j
            break
        }
    }

    lowest.count <- min(qual[,lowest.qual])
    highest.count <- max(qual[,lowest.qual])
    for(j in lowest.qual:highest.qual){
        lowest.count <- min(lowest.count, qual[,j], na.rm=TRUE)
        highest.count <- max(highest.count, qual[,j], na.rm=TRUE)
    }

    plot(x=0, y=0,
         xlim=c(lowest.qual, highest.qual),
         ylim=c(lowest.count, highest.count),
         xlab="Phred quality", ylab=ylab,
         main=main,
         type="n")
    for(i in 1:nrow(qual)){
        idx <- which(! is.na(qual[i,]))
        points(x=idx, y=qual[i,idx], col=i, pch=i, type="b")
    }
    axis(side=4)
    legend(x=legend.x, y=legend.y, legend=rownames(qual),
           col=1:nrow(qual), pch=1:nrow(qual), bty="n")
}
